# 《你不知道的JavaScript(上)》 读书笔记

# 第一部分 作用域和闭包

## 第一章 作用域是什么

在一个编程语言中存储变量，并且之后可以方便地找到变量的规则被称为作用域。

### 1.1 编译原理

尽管通常将JavaScript归类为“动态” 或 “解释执行”语言，但事实上它是一门编译语言。
但与传统的编译语言不同，它不是提前编译，编译结果也不能在分布式系统中进行移植。
尽管如此，JavaScript引擎进行编译的步骤与传统的编译语言的步骤非常相似，在某些
环节可能比预想的复杂。

传统语言的编译步骤：

1. 分词/词法分析

    这个过程会将字符串分解成对编程语言来说有意义的代码块，这些代码块称为词法单元。
    列如：`var a = 2;` 可以分解成 `var` `a` `=` `2` `;`。空格是否被当作词法单元，
    这取决于，空格对这门语言是否有意义。

2. 解析/语法分析

   这个过程会将词法流转成一个逐级嵌套组成的代表了程序语法结构的树，叫做抽象语法树（AST）。

   var a = 2; 的抽象语法树中可能有一个叫做VariableDeclaration的顶级节点，接下来有一个
   叫做Identifier（它的值为a）的子节点，以及一个叫做AssignmentExpression的子节点。
   AssignmentExpression节点有一个叫作NumericLiteral（它的值是2）的子节点。

3. 代码生成
   将AST转化为可执行代码的过程叫做代码生成。简单来说，就是有某种方法将var a = 2;的AST
   转化成机器指令，用来创建一个叫做a(包括分配内存等)的变量，并将一个值存在a中。

### 1.2 理解作用域

1.2.1

引擎：从头到尾负责整个javaScript的编译及执行过程。

编译器：引擎的好朋友之一，负责语法分析以及代码生产等脏活累活。

作用域：引擎的另一个好朋友，负责收集并维护所有声明的变量组成的系列查询，
并实施一套非常严格的规则，确定当前执行代码对这些变量的访问权限。

当你看到 var a = 2; 这段程序时，可能认为这是一个声明。但是引擎并不这么看。
事实上，引擎认为这里有两个完全不同的声明，一个由编译器在编译时处理，另一个
则由引擎在运行时处理。

编译器当遇到 var a, 询问作用域是否有一个该名称的变量存在于同一个作用域的集合中。
如果是，编译器则忽略该声明，继续编译；否则它会要求作用在当前作用域的集合中
声明一个新的变量，并命名为a。

接下来编译器会为引擎生成运行时所需的代码，这些代码用来处理 a = 2这个赋值操作。
引擎运行时会询问当前的作用域集合中是否存在叫a的变量。如果是，引擎就会使用这个变量；
如果否就会继续查找改变了。

如果引擎最终找到了a这个变量，就会将2赋值给它。否则引擎就会抛出一个错误。

1.2.2 编译器的术语

RHS查询与简单地查找某个变量的值别无二致，而LHS查询则是试图找到变量的容器本身，从而可以对其赋值

1.2.3 引擎和作用域的对话

### 1.3 作用域嵌套

引擎从当前作用域开始查询变量，如果找不到，就向上一级继续查找。当抵达最外层的全局作用域为止。

## 第二章 词法作用域

### 2.1 词法阶段

词法作用域是定义在词法阶段的作用域。换句话说，词法作用域是由你写代码时将变量和块作用域写在哪来决定的，
因此词法分析器处理代码时会保持作用域不变。

## 第四章 提升

直觉上会认为JavaScript会一行一行执行的。但实际上这并不完全正确，有一种特殊情况会导致这个假设是错误的。

···js
a = 2;

var a;

console.log(a);
```

你认为console.log(...)声明会输出什么呢？很多人都认为会输出undefined;
但是，真正输出的是2。